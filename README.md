# Data-compression via Clique Partitioning CLI Tool

A high-performance C++ tool designed to analyze sets of bit-vectors (containing 0, 1, and X don't-care bits) to find compatible groupings (Cliques) and merge them into optimized dictionary entries.

## Overview

This tool solves the problem of merging compatible bit-vectors. Two vectors are "compatible" if they do not have different bit values at any position where both have defined bits (0 or 1). The solver builds a compatibility graph and uses a heuristic clique-finding algorithm to group vectors, effectively reducing a large set of sparse vectors into a smaller, dense set of dictionary entries.

## Features

- **Compatibility Engine:** Handles 0, 1, and X (don't-care) logic.
- **Graph-Based Analysis:** Constructs an adjacency map of compatible vectors.
- **Greedy Clique Solver:** Implements a degree-based heuristic to find and merge the most "shareable" vectors first.
- **Dynamic Compression:** Merges cliques into single representative vectors for storage optimization.

## Installation and Usage

### Prerequisites
- A C++ compiler (GCC, Clang, or MSVC) supporting **C++11** or higher.

### Compilation
```bash
g++ -O3 data_compress.cpp -o vector_solver
```
### Execution
The program requires 4 command-line arguments:
```bash
./vector_solver <input_file> <num_entries> <vector_length> <output_file>
```
- **input_file:** Path to the text file containing bit-vectors (one per line).
- **num_entries:** The maximum number of merged dictionary entries you want to generate.
- **vector_length:** The expected length of each bit-vector (used for validation).
- **output_file:** Path where the resulting merged vectors will be saved.

### Input Format
The input should be a text file where each line is a string of 0, 1, and X. Example:
```text
10X1
0X11
1001
XXXX
```

## How it works
1. **Parsing:** Validates input dimensions and loads vectors into a memory-efficient structure.
2. **Graph Construction:** Every vector is a node; an edge is drawn between two nodes if they are "compatible."
3. **Clique Extraction:** The algorithm iteratively picks nodes with high connectivity to form cliques.
4. **Vector Merging:** For each clique, an optimized vector is generated by resolving X bits wherever possible based on the clique members.


This project is for educational/research purposes only. Feel free to modify and use it!
